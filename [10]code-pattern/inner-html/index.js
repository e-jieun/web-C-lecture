// 식별자 & 데이터
const root = document.getElementById('root');
const menuItmes = ["피카츄", "라이츄", "파이리", "꼬부기", "버터풀", "야도란"];

// element를 만드는 함수들
const headerMenu = (array) => {
  // * headerMenu 함수는 파라미터로 일련의 배열을 받기로 했다.
  let menuList = [];
  // * headerMenu 함수 내에서만 사용할 배열 menuList를 초기화(init) 했다. 
  menuList.push('<ul>');
  // * menuList 배열에 첫번째 원소로 <ul>태그 처럼 보이는 문자열 "꺽쇠유엘꺽쇠"를 push : 밀어넣었다.
  array.forEach(element => {
    // * 파라미터로 받은 배열을 forEach문으로 loop를 돌렸다.
    menuList.push(`<li>${element}</li>`);
    // * 위의 push("<ul>")과 마찬가지로 "태그 처럼 보이는 문자열을" 반복문을 통해 연속으로 밀어넣었다.
    // * 차이점은 ${element} = 즉 menuItems의 배열 원소들을 뜻한다.
  });
  menuList.push('</ul>');
    // * 지역변수 menuList 마지막원소에 "</ul>" 닫는 태그처럼 보이는 문자열을 밀어넣었다.

    // pseudo 1. menuList 라는 배열은 순서의 용도라기보다 , '값을 여러개 저장하는' 용도로 사용한 것에 가깝다.
    // pseudo 2. 임시로 만든 배열에 필요한 만큼 반복한 어떤 값을 밀어넣어 저장했다 라고 표현할 수 있다.
  return menuList.join("");
  // ? return의 용도
  /*
    * .join("") : 조인 메서드는 원래 '원소마다 무언가 구분을 지어 넣겠다' 라는 용도에 가깝지만 위와같이 "" 빈칸의 문자열을 넣는다면
    * .join("") : 아무것도 구분하지 않고 붙이겠다.로 해석된다.
    * 따라서 headerMenu() 함수는 return(반환)이 '문자열'이 된다. -> ★ 문자열처럼 사용한다. ★
    * 함수를 호출한다면 어떤 문자열을 작성한 것과 같은 일이 되기 때문에 아래의 작업에서 문자열자리에 덩그러니 함수를 호출한 것을 확인할 수 있다.
  */
  
}

const mainContent = () => {
  return `
    <section>캡슐로묶었다.</section>
  `;
}

root.innerHTML = `
  <header id='header'>${headerMenu(menuItmes)}</header>
  <main id='main'>${mainContent()}</main>
  <footer id='footer'></footer>
`;

/* 
  ? root.innerHTML = ``;

  * root.innerHTML 키의 특성을 활용해 DOM tree 구성
  * 결과적으로는 HTML로 작성한 것과 다를바 없는 예제이나, 자바스크립트에서 처리하고자 하는 코딩 패러다임은 react, vue 와 같은 프론트엔드 프레임워크에서 매우 활발히 사용하고 연구되어지는 사항 중 하나이다.
  * 이러한 구조를 객체로 만들어 제작한다면 -> 객체지향방식의 프론트엔드 디자인
  * 이러한 구조를 함수로 만들어 제작한다면 -> 함수형프로그래밍 방식의 프론트엔드 디자인
  * 비약이 존재하지만 대략적으로 두개의 '코딩 스타일'이 존재한다.
  
  ? 굳이 위와같이 자바스크립트에서 DOM 조작을 하려는 이유는 무엇일까?
  * 1. 사용자가 클릭했을때 다른 페이지로의 전환이 일어나는 사항에서 기존의 페이지 이동 방식은 매번 '로딩' 즉, 적재를 다시해야한다.
  * 2. 로딩에 대한 피로도 및 서버관련 부하 비용 등 여러가지가 고려되었을때 사용자가 해당 서비스를 '최초접속' 했을때 필요한 모든 요소를 전달한다면 두번째 접속에서는 그 비용을 대폭 줄일 수 있게 된다. 이러한 개념이 client side rendering : CSR 방식으로 사용자의 하드웨어에서 웹사이트 구축(랜더링)을 맡기게 된다.
  * 3. react, vue와 같은 프레임워크들이 대표적인 ★CSR 방식★을 기본으로 하고 있다.
  * 연산이 가능한 프로그래밍으로 제작되기 때문에 기존 '문서'의 한계를 뛰어 넘어 애플리케이션(프로그램) 처럼 사용할 수 있는 것이 사람들이 통칭하는 '웹앱'의 개념이다.
  * 4. 매번 장점만 있는 것은 아니다
  * 4-1. 단점 : 최초 접속에서의 로딩이 매우 느릴 수 있다.
  * 4-2. 단점 : 사용자의 하드웨어가 좋지 않을 경우 문제가 생길 수 있다.
  * 5. 단점들 때문에 최초접속은 서버에서 제공하고 나머지는 클라이언트에서 해결하는 방식과같은 '고차원적인' 엔지니어링들이 활발히 연구되고 있으며 이러한 개념을 react 개열의 프레임워크에서는 Next.js가 담당하고 있다.
  * 위의 예제가 바로 SPA single page application : SPA 패러다임의 기둥 개념이다.
   



*/
