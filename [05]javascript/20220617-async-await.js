let a = setTimeout(() => {
  console.log("첫번째 작업입니다.");
}, 1000);
let b = setTimeout(() => {
  console.log("두번째 작업입니다.");
}, 2000);
let c = setTimeout(() => {
  console.log("세번째 작업입니다.");
}, 3000);

/* 
  work .1 a는 1초, b는 2초 c는 3초의 텀을 두고 실행하게 작성하였다.
  pseudo.1 setTimeout()과 같은 '비동기' 함수는 효율적인 코드 처리를 위해 순서대로 기다려가며 절차를 지키는 '동기' 방식과 다르게 동작한다.
  pseudo.2 먼저 끝날 수 있으면 먼저 끝낸다. 라는것이 '비동기'의 핵심 개념이다.

  * 여건상 처리해야할 데이터가 매우 많은 경우(몇십기가바이트의 계산을 해야하는등)에는 위의 코드라고 했을때 총합 6초가 걸릴 실행을 '최종' 3초에 모두 끝내버릴 수 있게 된다.
  * 다른 두가지가 순서에 '상관없다면' 비동기 처리가 압도적으로 효율적이다.
  * 하지만 디자인 작업에서의 제어는 의외로 a작업이 끝난뒤에 그 다음 b작업을 해야만 하는 경우가 발생한다. 이것은 동기방식이라고 프로그래밍에서는 부르고 있다.
  * 순서를 지킨다 = 동기
  * 순서를 지키지 않는다 = 비동기
  * 대부분 동기 방식으로 처리가 되나, 특별히 동기방식 기반이 아닌 것이 setTimeout, setInterval과 같은 함수들이 존재한다.
  * 순서대로 차례를 지켜 움직여야 하는데 동시에 실행되어버리는 현상을 발견할 수 있다.

*/

function funcA() {
  return new Promise((resolve) => {
    setTimeout(()=> {
      resolve("네번째 작업을 1초 기다렸다가 실행했습니다.");
    }, 1000);
  });
};
function funcB() {
  return new Promise((resolve) => {
    setTimeout(()=> {
      resolve("다섯번째 작업을 1초 기다렸다가 실행했습니다.");
    }, 1000);
  });
};

/* 
  ? return new Promise()

  * funcA()와 funcB() 리턴 데이터를 확인하면 매우 특이한 점을 확인할 수 있다.
  * 직역그대로 "약속"이라는 뜻의 promise 생성자 함수의 '인스턴스"
  * return 에 값으로 담기는 모양새는 보통 문자열, 숫자, 객체, 등등 기본적인 데이터타입을 담는 것이 일반적인데
  * 이러한 동기 비동기처리는 새로운 new Promise 인스턴스를 리턴하는 것이 매우 특이하다.
  * *** promise 때문에 중구난방으로 동작하는 동기, 비동기 제어를 필요한 만큼 순차적으로(동기적으로) 제어할수도, 동시에(비동기적으로) 제어할 수도 있는 능력을 갖추게 된다.
  * 
  * <div> 를 마크업하고 console.dir() 로 조회했을때 수 많은 객체의 프로퍼티가 새겨지는  것을 확인할 수 있었듯,
  * promise는 '어떤 동작'을 제어하는 '전용'의 객체를 생성한다.
  * 데이터 처리 방식으로'만' 보면, <div> 나 new promise 나 동일한 '인스턴스' 라는 객체이다.
  * 
  * 위의 방식으로 '동작하는 과정을 핸들링 할 수 있다.'
  * setTimeout() 과 같은 비동기 함수를 '순서대로' 제어 하는 연습을 진행한다면, 원할때 움직이는 웹 모션, 외부 통신 데이터들을 원활하게 사용할 수 있게된다.
  * 
*/

async function actionFunc() {
  let result;
  result = await funcA();
  console.log(result);
  result = await funcB();
  console.log(result);
}
/* 
  ? async, await? 
  ? 위의 promise를 다룰수 있게 된다면, 이것을 편하게 사용할 수 있는 문법을 사용할 수 있다.
  * async, await = Promise 이다.
  * 선언적으로 작업하는 것이기 때문에 Promise를 핸들링 할 수 있을 때 연습목표로 삼을 것을 권한다.
  * 
*/
actionFunc();