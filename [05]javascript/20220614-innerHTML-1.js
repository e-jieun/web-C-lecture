const htmlEscapeExample = str => [...str].map(c => c === '<' ? '&lt;' :
  c === '&' ? '&amp;' : c).join('');
// ? htmlEscapeExample 함수 설명
/*
  pseudo 1. 위의 htmlEscapeExample 함수는 전혀 함수처럼 보이지 않지만, 매우 압축된 함수이다.
  pseudo 2. 현업 자바스크립트 개발자들이 사용하는 전형적인 코딩패턴으로 간략화 할 수 있다면 최대한 간략하게 작성하는 것이 생산성과 직결된다.
  pseudo 3. 하지만 처음 입문하는 자는 당혹스러운 코드 일 수밖에 없다. 너무 많이 추상화되어있어서 어디서 어떻게 작동했는지를 알기가 쉽지 않는건 매우 자연스러운 일이다.
  pseudo 4. ES6+(최신버전)의 축약형 작성법(syntax)를 사전에 익혀보고, 위와 같은 코드를 분리하여 어떤 작용을 하였는지 아래의 예제와 같이 풀어보는 연습이 매우 좋은 연습이다.
  
  ? syntax
  * [...문자열] : ... 스프레드 연산자 (spread operator) 라고 하며 본디 사용처는 배열을 추가하거나 합치는 과정을 축약해서 사용하기 위해 만들어졌다.
  * [...문자열] : 문자열도 일종의 배열이기때문에 배열로 처리하겠다는 일련의 명령적 작성법을 선언형으로 바로 바꾼 사례이다.
  * 
  * array.map((value)=> {}); : 배열 전용 선언형 반복문 메서드 중 한 종류인 map()
  * : 배열을 순회하면서 array[index]번째의무언가의 값을 바꾸어 다른 원소들로 채운 새로운 배열을 만들어주는 매우 유용한 메서드이다.
  * array.join(','); : 배열 전용 선언형 방복문 메서드 중 한 종류 .join();
  * : 배열을 순회하면서 현재원소와 다음원소를 구분자(윗줄에서는 쉼표 ","가 구분해주는역할)를 통해 '하나의 문자열'로 바꾸어주는 역할을 한다. 리턴은 문자열(string) 이다. 
  * 
  * 위의 함축된 작성예시를 명령방식처럼 명시적으로 작성하면 아래의 풀이와 같다.
*/

function htmlEscape(str) {
  let arr = [];
  for (let i = 0; i < str.length; i++) {
    arr.push(str[i]);
    // ? 문자열을 한 음절마다 따로 임시 배열의 원소로 밀어 넣는 반복문이다.
    /*
     * "안녕하세요" 라는 문자열이 해당 반복문을 만나게 되면
     * arr = ["안", "녕", "하", "세", "요"]; 라는 배열로 데이터타입이 완전히 바뀌게 된다.
     * 문자열도 순서값(index)라는 것이 존재하지만, 배열메서드를 원활하게 사용하지 못하기 때문에
     * 일반적으로 문자열을 필요에 의해 편집,혹은 할당하고자 한다면 위와같이 처리하는 편이다.
     */
  }
  /*
    ? 위의 반복문에서 문자열 -> 배열화 시키는 가공이 끝난 후
    ? 아래의 map() 함수를 통해 원소를 조회하고 있다.
  */

  arr.map((value) => {
    // ? 여기에서 써져있는 value는 for() 문에서 arr[i]와 같은 역할을 한다.

    if (value === "<") {
      value = '&lt;' //? 부등호 "<" 왼쪽꺽쇠를 &lt로 표기할 수 있다. 문자열 원소 "<" 값을 동일한 역할을 하는 특수기호로 바꾼다.
    } else if (value === "&") {
      value = '&amp;' //? "&" shift + 7번 누르면 나오는 엠퍼센드 기호를 뜻한다.
    } else {
      value;
      // * 해당되지 않는다면 그대로 둔다는 뜻으로 else 를 사용
    }
  })
  return arr.join(''); //? 모든 배열의 원소를 다시 원래대로 하나의 문자열로 합치는 과정
}
// ? htmlEscapeExample 함수 알고리즘 내부에서 return이 별도로 존재하지 않는이유는 해당 함수 안에(.map) return 이 장착되어있기 때문에 쓰는경우도, 혹은 쓰지 않는 경우도 있다. 
// * 기본적으로 배열메서드는 무언가 새로운 배열로 재조립하는 경우가 매우 많다.



// TODO : 함수형 배열 처리
const pokemonArray = ["피카츄", "라이츄", "파이리", "꼬부기", "버터풀", "야도란"];




const enclosed = (tag, content) => `<${tag}>${content}</${tag}>`;
const listItmes = pokemonArray
  .map(htmlEscape) //? 1번 .map() 
  .map(i => enclosed('li', i)); //? 2번 .map() 
  
  /*
    ? array.map().map(); : 패턴
    * 위와같이 메서드(함수)가 연달아 붙어있는 것을 메서드체이닝, 펑션체이닝이라 부른다.
    * 함수 리턴값이 특정할 때만 사용할 수 있는 방식이며, map() 메서드는 배열을 반환하기 때문에
    * (array.map).map() 사실상 어떤 특정 배열에서 .map() 함수를 설치한 것과 동일한 효과를 가진다.
    * const arrayOne = array.map(); // arrayOne은 배열
    * const arrayTwo = arrayOne.map();
    
    * 특정 메서드의 특정 리턴을 알고 있거나, 자주사용할때 활용하는 코드패턴이며, 위의 예제를 확인하면
    * 첫번째 .map()으로 "<", "&", 라는 문자열을 안전하게 특수기호로 치환하여 다시 배열로 재조립(리턴)
    * 두번째 .map()으로 태그처럼 보이는 문자열 만드는 과정
    * 으로 공정이 처리되어 listItmes 라는 변수에 문자열이 담겼다.
  */
const mainText = `
  ${listItmes}







`;