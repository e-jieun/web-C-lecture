let timerA = setTimeout(() => {
  console.log('timerA : 3초 뒤에 실행');
  let timerB = setTimeout(() => {
    console.log('timerB : 2초 뒤에 실행');
    let timerC = setTimeout(() => {
      console.log('timerC : 1초 뒤에 실행');
    }, 1000);
  }, 2000);  
}, 3000);  

/* 

todo : 20220603-asynchronous-basic-2번 파일과 비교해서 코드를 확인 할 것

pseudo 1. 원하는 순서대로 '비동기 처리'와 관계없이 '동기적'으로 처리하고자 할 때 할 수 있는 강구책이 바로 위에 있는 방식이다.

pseudo 2. 구조를 자세히 들여다보면, 함수안에 함수를 실행하는 구조가 되어있다.
pseudo 3. 이러한 함수 구조를 함수를 다시 부른다고하여 '콜백함수' 라 부른다.

* A-1. timerA는 3초 기다렸다가 console.log()을 동작시키는 것부터 실행한다.
* A-2. console.log() 실행 후, 다음 행(row)에 있는 timerB를 실행시킨다.
* A-3. timerA 함수 영역 내부에서는 순차적으로 실행하는 '동기' 방식이다.
* A-4. 결과적으로는 작성된 순서대로 '실행주기와 관계없이' 실행되는 것을 확인 할 수 있다.

pseudo 4. 이러한 구조로 작성하여 '정상적으로' 작동하지만, 치명적인 단점이 존재하는데 바로 '가독성' 이 매우 떨어진 다는 것이다.
pseudo 5. 단 세개의 함수에 대해 원하는 동작의 작동 시키는 것에 영역(scope)이 너무나 많이 중첩된 것을 확인 할 수 있다.
pseudo 6. 이는 가독성 뿐만아니라 '동작'을 관장하는 주요 코드의 개발에 실수를 유발할 수도 있는 중대한 사항으로 번질 수 있다.
pseudo 7. 이런 방식의 작성법은 본질적으로 틀리지는 않았지만, 가용성이 매우 떨어지기에 개발자들 사이에서는 이러한 코드패턴을 '콜백지옥' 이라고 부른다.




*/

  



