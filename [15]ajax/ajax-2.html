<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>
  <div id="root"></div>
  <!-- todo : 비동기 통신 AJAX 기술을 사용하기 위한 사전 준비 -->
  <!-- 
    work .1 http://kobis.or.kr/kobisopenapi/homepg/main/main.do 
    ? 1. 위의 웹사이트에 가입한다.
    ? 2. 키 발급 관리 메뉴에서 키를 발급 받는다.
    ? 2-1. 간단한 정보기재가 있으며, 사용처를 명시하기만 하면 바로 키를 발급해준다. (무료)
    ? 2-2. 발급 받은 키는 마치 소프트웨어 시리얼 키 처럼 개인정보에 해당하므로 온라인에 개재되는 것을 주의한다.
    * 일반적으로 무료 API는 일일트래픽(접속량, 접속횟수)의 제한을 두기 때문에 의도치 않는 외부사람이 사용하는 경우 막힐 수 있다.
    * 경우에 따라서는 상업적 활용(저작권문제)는 따로 API 발급을 다르게 받아야 한다.
    * 정식 릴리즈 되는 서비스의 경우 API 키에 대한 부분을 암호화 처리를 통해(매우다양하다) 해결하거나 백엔드에서 보안 부분을 해결한뒤 활용한다. 
    ? 3. 상위 메뉴 중 '제공서비스'의 메뉴를 참조하여 구성한다. 
    * API는 DOM API와 동일한 구조를 가지고 있기 때문에 MDN 웹사이트에서 정보를 찾아 사용하듯 외부 API도 동일한 형태를 가지고 있다.
    work .2 개인이 받은 키와 API 주소를 준비한다. (아래 코드 참조)
   -->
  <script>
    const ajax = new XMLHttpRequest();
    /*
    <!--
      ? AJAX : asynchronous javascript and XML
      ? 비동기 통신이라는 뜻의 준말로 외부에서 데이터를 받아올때 사용하는 기술을 의미한다. 
      ? new XMLHttpRequest() : 인스턴스의 메서드 이름을 살펴보면
      pseudo .1 XML : extensible markup language 의 준말로 HTML마크업의 원형이자, 본디 용도는 '데이터 저장용도'로서 개발된 웹용 메모장과 같은 데이터를 뜻한다.
      pseudo .2 HTTP : Hypertext transfer protocol : 문서를 통신하는 '규약'을 이야기 하는 웹'문서' 통신규약
      pseudo .3 request : 직역하면 "요청"하다라는 뜻으로, 의역하면 "서버에게 '문서'를 가져와달라고 요청"하는 행위를 말한다.
      pseudo .4 정합적으로 정리하면
      * "XML방식으로 통신규약을 통해서 데이터를 요청하고 싶어" 라는 말로 의역할 수 있다.
      * new 키워드가 붙었다는 뜻은 어떤 생성자함수(붕어빵틀)에서 찍어져 나온 인스턴스(붕어빵)이며, '객체' 타입임을 의미한다.
      * <div></div>를 생성하고 조회하면 일련의 객체 데이터를 (CSS를 포함한) 생성한 것과 같은 맥락이다.
      * new Div() 라고 하지 않을 뿐이다.
      * 따라서 HTML은 아니지만, HTML의 원형인 XML 방식으로 값의묶음(객체)를 가져오겠다는 뜻이된다.
      * 
      * 여기서 비동기(순서를 처리완료순으로 진행하는)방식이라고 명시되어있는 것은
      * 통신의 특성상 '큰 데이터'를 불러올땐 얼마간의 데이터 전송시간이 존재 했을때, '동기적'으로 처리한다면 '모든 데이터가 다 적재(load)될 때까지' 기다려야 하는 불편함이 생긴다. 하지만 '비동기'적으로 처리했을땐 원하는 데이터만 최대한 빨리 가져올 수 있기 때문에 '통신' 측면에서는 거의 대부분 비동기 처리를 하는 것이 일반적이다. 
      
      ? 결과적으로 const ajax = new XMLHttpRequest(); 구문의 뜻은
      ? 외부의 데이터를 통신을 통해 '여기 문서'에 로딩 할 준비를 하겠다. 라는 말로 해석할 수 있다.
    -->
    */
    const myKey = `a3be73f165bde17dddd626f733831fdc`;
    const test = `targetDt=20220623`;
    const _URL =`http://kobis.or.kr/kobisopenapi/webservice/rest/boxoffice/searchDailyBoxOfficeList.json?key=${myKey}&${test}&itemPerPage=10`;

    /* <!--
      ? URL을 가져오는 의미
      pseudo .1 제작과정상 '데이터를' 디자이너, 제작자가 직접 제작하는(컨텐츠 제작)경우가 많지만 다른 사람이 만든 데이터를 '가져오는' 것이 엔지니어링에서는 훨씬 더 많다. 즉 일반적으로 개발작업에서는 컨텐츠 '제작' 보다는 컨텐츠 데이터 '가공'이 어울리는 어휘 이다. (컨텐츠 제작 : 퍼블리셔, 디자이너, 글작가 등등 / 컨텐츠 가공 : 엔지니어)
      pseudo .2 일련의 링크로 되어있는 구조는 '파일 자체'를 모듈로서 사용하는 방식이 아닌 '주소'를 파일처럼 사용하는 방식이다.
      * 별다른 파일 다운로드 과정 없이 '주소에 원하는 데이터를 볼 수 있게끔' API 제작자가 구성해놓았다.
      * (URL 링크에 접속한다는 것 자체가 파일 다운로드이다)
      * 요구하는 파일유형이 상당히 많이 때문에 이를 구별하고자 링크에 '주소' 만 적어서 사용하는 것이 아니라 
      * '주소' + '원하는 파일 데이터 정보' 를 함께 적는 방식을 채택하고 있다.
      * 이러한 구조를 query string (질의, 질문 문자열)이라고 부르며
      * "문자열"을 링크주소에 붙여 원하는 데이터를 가져오겠다는 뜻이 된다.
      * 여기에 주소와 요청데이터의 구분을 위해 약간의 문자열 작성 규칙이 존재하는데
      * 통신규약://도메인주소/접근하는폴더/마련된파일 물음표(?) key= "시리얼키" & "원하는 데이터 항목" =(이퀄) "원하는 데이터의 이름"
      * (일반적으로) 위와 같이 '주소'를 구성해놓았다.
      * 통신을 다룰때 알아두어야 하는 포인트는 ?(물음표)를 확인하면 된다.
      * ?물음표 앞편 : 주소와 접근하는 파일을 뜻한다.
      * ?물음표 뒷편 : 원하는 자세한 데이터를 뜻한다.
      * 데이터를 작성하는 것은 &(엠퍼센드) 기호로 구분한다.
      * 원하는 데이터 항목 : 일반적으로 객체의 키에 해당한다.
      * 원하는 데이터 이름 : 일반적으로 객체 키의 값 부분에 해당한다.
      
      ? const test = `targetDt=20220623`;
      * test로 명시한 해당 문자열을 해석하면 다음과 같다.
      * targetDt : 제공해주는 API의 '키'이름에 해당하며 API 문서에 어떻게 사용하는지, 어떤 방식으로 데이터를 정리했는지가 명시되어있기 때문에 이름을 외울수는 없다.
      * = : 키와 값을 구분하는 구분자에 해당한다.
      * 20220623 : 위의 키가 요구하는 데이터 타입이 숫자로된 문자열임을 뜻한다.
      
      ? 결과적으로 _URL 이라는 변수는 특정날짜의 영화 순위를 가져오는 일련의 키와 데이터들이 묶여있다.
      * '문자열을 원하는데로 제어' 하면 -> 원하는 '데이터'를 받아낼 수 있다. 가 된다.
    --> */
    // console.log(_URL);
    /* <!--
      ? _URL 문자열을 그대로 브라우저에 옮겨 접속하면 "특정 객체"가 있는 것을 확인할 수 있다.
      * 즉 문자열을 원하는 정보로 바꾸어 다시 주소를 조립하면 다른 데이터를 얻을 수 있다.  
    -->
    */
    ajax.open("GET", _URL);
    /* 
    <!-- 
      ? new XMLHttpRequest() 객체에서 제공하는 .open() 함수이다.
      ? 위의 코드를 해석하면 비동기 통신 준비를 마치고(new XMLHttpRequest()) 함수안에 있는 데이터를 'GET'(통신방식) 가져오겠다 라는 작성이다.
      * GET, POST : 데이터를 요청할때 사용하는 특정 방식이 여러개 존재한다. 일반적으로 디자이너와 프론트엔드에서는 GET, POST 정도만 활용하고 있고, 백엔드(파일자체를 제어하는)에서는 PUT, DELETE 와같은 다양한 방식을 활용한다.
    -->
    */
    ajax.responseType = "json";
    /*
    <!--
      ? ajax.responseType = "json";
      * 가져오는 데이터 타입을 JSON 방식으로 해석하겠다는 뜻이며,
      * JSON은 자바스크립트의 객체 스타일로 된 데이터 타입이다. (특유의 장점 때문에 XML을 대체하고있다.)
    -->
    */
    ajax.send();
    /* 
    <!-- 
      ? ajax.send();
      * 위에서 GET 하여 가져온 데이터를 열고(open), 보는 방식을 json 타입으로 보는 것으로 데이터를 .send() 메서드를 통해
      * "결과값"을 가져오겠다. 라고 할 수 있다. 
      * send(); 메서드를 사용하지 않으면 외부주소인 해당주소에서 '읽기'만 할 뿐 본 문서로 데이터를 가져오지 않는다.
      -->
    */
    ajax.addEventListener('load', () => {
      // 비동기통신 이 load(적재) 되었을때 아래의 구문을 실행하겠다.
      const _movieAPI = ajax.response;
      /* 
        <!--
          ? 위의 ajax.send(); 메서드를 통해 데이터를 가져왔을때 저장되는(가져오는) 위치는 .response 객체에 담겨있게 된다.
          ? 통신을 통해 일련의 과정을 정리하면  
          * 연다(open()) -> 타입 지정한다(json) -> 받아온다(send()) -> 받은것을 조회한다.(response)
          * 복잡하지만 위와같은 '절차'가 필요하다.
          * 절차가 무사히 완성되면 위에 변수로 담겨진 _movieAPI는 그저 하나의 객체로 '가공'되어있음을 확인 할 수 있다. 
        -->
      */
      console.log(_movieAPI);
      // 조회하면 여러개의 키와 값이 통신으로 받아져 가공된 것을 확인 할 수 있다.
      const boxOfficeList = _movieAPI.boxOfficeResult.dailyBoxOfficeList;
      // 객체의 키를 조회하면서 박스오피스 순위가 정리된 배열에 '접근' 했다.
      for (let i = 0; i < boxOfficeList.length; i++) {
        console.log(`${i+1}등 영화 : ${_movieAPI.boxOfficeResult.dailyBoxOfficeList[i].movieNm}`);
        // 간단히 반복문을 통해 순회하며 1등부터 10등까지의 순위를 콘솔로 기록하게끔 제어했다.
      }
    });




  </script>
</body>

</html>