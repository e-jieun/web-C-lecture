const test = new Promise((resolve, reject) => {
  resolve(); 
  // resolve : 이행하다, 귀결되다 라는 뜻을 가지고 있다.
  // reject : 거부하다, 실패했다 라는 뜻을 가지고 있다.
});

/*

  * test라는 이름의 Promise 인스턴스는 특별한 객체 이다.
  * 인스턴스 : 생성자함수에서 복제된 특정한 객체값
  * 동기적으로(주문 순서대로), 비동기적으로(실행순서대로) 처리 하는 것을, 보다 편하게 제어하기 위해 고안되었다.
  * 
  ? Promise를 사용하게 되는 시점은 다음과 같다.
  pseudo 1. 여러가지 복합적인 연산의 순서를 정리해야 할 때
  pseudo 2. 엄격한 순서를 지키는 연산을 동시에 처리해야 할 때 
  pseudo 3. 순서를 어기고 실행완료부터 하는 연산을 순서에 맞게 처리하고 싶을 때

  ? 비유하면 다음과 같다.
  * 만들기 오래걸리는 양장피가 있고, 만들기 간단한 짜장면을 어떻게 효율적으로 처리해야할까? 라는 물음에서
  * 짜장면이 먼저나오니 기다릴 것 없이 주문이 나중에 들어왔어도 먼저 처리해주자 라는 발상이다.
  * 이러한 것을 '비동기 처리' 라고 하며,
  * 작성 순서보다는 실행완료를 최대한 효율적으로 처리하기 위해 고안된 동작방식이다.
  * 매번 모든 동작이 먼저 끝나는 순으로 정리되면 좋겠지만 필요한 경우는 순번대로 동작이 진행되어야 할때가 존재한다.
  * 비유로, 양장피가 아무리 만드는것에 오래걸려도 늦게 주문한 짜장면이 먼저 나오면 안되는 상황을 이야기한다.
  * 비유로, 반드시 선착순으로 처리해야하는 생활속 순서가 이러한 예를 들수 있다.

  ? 동기 vs 비동기를 가지고 씨름하는 이유
  pseudo 1. 자바스크립트가 지원 하는 코어메서드들 중에는 편의를 위해 다양한 설정들이 커스텀 되어있는데 그에 따른 목적이 분명한 편이다.
  pseudo 2. 순번대로 연산하는 함수와 그렇지 않은 함수가 나뉘어져 있고, 만들어진대로 활용하는 경우가 보통이지만 "정 반대로" 사용해야 될때가 발생하기 때문이다.
  
  pseudo 3. A 동작이 끝나야만 B 동작을 하게끔 알고리즘이 작성되어있는데 A 동작이 끝나지도 않은 상태에서 B 동작이 실행되어버리면 에러, 서비스 장애가 일어날 수 있기 때문이다.

  pseudo 4. 애니메이션, 모션과 같은 경우 보통 비동기 함수를 동기적으로 활용하려는 시도가 많다.
  pseudo 4. A 장면, B 장면, C 장면이 순서대로 나타나야되는데 섞여서 나오면 곤란해지기 때문이다.

  pseudo 5. 서버관리 같은 경우는 동기방식의 처리를 비동기적으로 처리하려는 시도가 많다.
  pseudo 5. 동시에 많은 사람이 접속한다고 했을때 조금 먼저 접속한 사람이 많은 요구(시간이걸리는)를 했다면 그 다음사람은 기다려야하기때문이다. 

  todo : 위의 설명한 개념의 키워드를 꼽는다면 다음과 같다
  todo : 콜백헬, promise, async, await 
  ? 이러한 단어들이 '처리 순서', '처리 방식'을 제어하는 주요 키워드이다.

  ? 보이지 않는 순서를 제어해야 하는 부분과 컴퓨터의 특이성 때문에 '흐름'을 잡아내기가 상당히 어려운 편이다.

  ? 하지만 해당 흐름을 잡아내어 '필요한 만큼의 제어'와 필요한 순서의 연산을 핸들링 할 수 있다면 다양한 시도와 처리를 접목할 수 있다.

  * 동작 순서를 까다롭게 제어해야하는 상황에 직면한 경우에 이해하여 사용한다면 까다로운 조건을 직관적으로 제어 할 수 있게 된다.





*/


test.then(a);


function a() {
  console.log("a라는 함수가 실행되었습니다.");
}
